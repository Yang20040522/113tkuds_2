// 題目：Valid Sudoku
// 以 bitmask 一次掃描驗證 9x9 局面是否有效（行/列/九宮格不得重複）

public class It_36_ValidSudoku {

    public boolean isValidSudoku(char[][] board) {
        int[] rows = new int[9], cols = new int[9], boxes = new int[9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c == '.') continue;

                int d = c - '0';   // 1..9
                int bit = 1 << d;
                int b = (i / 3) * 3 + (j / 3);

                if ((rows[i] & bit) != 0 || (cols[j] & bit) != 0 || (boxes[b] & bit) != 0) {
                    return false;
                }
                rows[i] |= bit;
                cols[j] |= bit;
                boxes[b] |= bit;
            }
        }
        return true;
    }

    // ===== 測試 =====
    public static void main(String[] args) {
        It_36_ValidSudoku s = new It_36_ValidSudoku();

        char[][] board1 = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        System.out.println(s.isValidSudoku(board1)); // true

        char[][] board2 = {
            {'8','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        System.out.println(s.isValidSudoku(board2)); // false
    }
}

/*
解題思路（清楚版）：
- 限制只需檢查「已填」格。
- 用三個集合追蹤每列、每行、每宮是否出現過某數字。
- 我們用 32-bit 整數當集合：第 d 位表示數字 d 是否已出現。
- 走訪每格：
  * 若為 '.' → 跳過。
  * 否則計算對應 bit；若在該列/行/宮任一集合已經存在 → 立刻回 false。
  * 否則把該 bit 加入三個集合，繼續。
- 所有格子處理完而沒有衝突 → true。
時間 O(1)（固定 81 格），空間 O(1)。
*/
